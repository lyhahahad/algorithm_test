*그래프
그래프를 표현하는 방식에는 크게 두 가지가 있다.
G(V : 정점의 집합, E : 연결의 집합)
노드 개수 : n, 연결 개수 : m
1.인접 행렬 : directed, weighted에 적합.
메모리 = o(n*n)
두 노드의 연결성 찾기 = o(1)
u에 인접한 모든 노드에 액션을 취할 경우 = o(n*액션), n가지를 모두 체크해야 알 수 있다. 무조건 n번 반복하게 돼있음.
새로운 엣지를 삽입한다고 했을 때 o(1) 그냥 해당 인덱스에 숫자를 넣으면 됨.
기존 엣지 제거했을 때 해당 인덱스 값 제거하면 됨. o(1)

=>메모리 낭비가 있기 때문에 directed, weighted 그래프일 경우
=>두 노드의 연결을 확인할 때 연산이 많지 않다. 두노드 연결 상태 확인하는 연산이 많은 경우

2.인접 리스트 :
메모리 = O(n+m)
두 노드의 연결성 찾기 = o(m)
u에 인접한 모든 노드에 액션을 취할 경우 = o(인접한 노드수*액션)
새로운 엣지를 삽입한다고 했을 때 pushfront를 하기 때문에 o(1)이다.
기존 엣지 제거했을 때 우선 찾아야 한다. 찾고 지워야 한다. 최악의 경우 o(m)

=>메모리 측면에서 인접 행렬보다 우수.

*인접 행렬과 인접 리스트 어떻게 적용할까?
directed, weighted 그래프일 경우 인접행렬
+엣지제거, 두 노드 연결성 확인 많이 할 경우 
+엣지가 많을 경우(dense 그래프) - 엣지의 개수와 관계없이 동작한다.
undirected, unweighted 그래프일 경우 인접 리스트
+인접한 노드 액션이 많을 경우
+엣지가 적을 경우(sparse 그래프) - 엣지의 개수와 상관관계가 있다.
인접행렬은 메모리 낭비가 많은 만큼 많은 메서드에서 더 유리하다.
=>엣지 개수, 어떤 함수를 많이 사용하나를 기준으로 판단하면 된다.

*DFS와 BFS.
이진트리의 순회 방식 PRE(부모, 왼자, 오자), IN(왼,부모,오), POST ORDER(자식노드 방분하고 마지막에 부모)
이진트리가 아닐 경우 PRE는 부모를 방문하고 자식을 왼족부터 방문하면됨.
이진트리가 아닐 경우에는 IN ORDER 불가능
트리가 아니라 사이클이 존재하는 그래프일 경우에는 3가지 모두 적용이 불가능하다.
이때 등장하는 것이 DFS와 BFS이다.
=>사이클이 존재하는 그래프를 탐색하는 규칙 DFS, BFS