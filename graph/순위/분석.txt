
2.5
위와 같은 인접리스트 방식과 두가지 관계를 표현한 리스트 두가지 풀이 수도코드 작성.

-problem :
그래프의 연결 관계에서 확실하게 순위를 알 수 있는 노드의 숫자를 구해라.
그래프에 어떤 연결 관계가 있을 때 순위가 확실한지 조건 생각하기.

-input : 노드의 숫자 n과 승리 관계

-output : 확실히 순위를 알 수 있는 노드의 개수.

-design strategy : 
주어진 입력 값 그대로 규칙을 효율적으로 규칙을 발견하고 사용할 수 있다면 그대로 풀면 되고 안된다면 인접 행렬을 사용해 풀어볼 수 있다.
1.주어진 인접 리스트를 활용해 풀기.
노드 하나하나 순위를 알 수 있는지 기록하기 위해 관계가 담겨 있는 리스트를 순회해야 한다.
또한 순위를 반드시 알게 된 노드를 통해 추가적으로 알 수 있게 되는 경우가 생길 수 있어 2회 순회해야 한다.
때문에 n*results 개수(모순이 없기 위해서는 최소 n-1개가 필요함.)
O(n^2)으로 매우 비효율적인 알고리즘이 나온다.

2.인접행렬 이용해 풀기.
그래프 표현 방식 : 인접 리스트 vs 인접 행렬
기준 : 어떤 연산이 많이 필요한가?/ 복잡한 연결관계를 표현하는가?
승리 관계라는 다소 복잡한 관계를 표현해야 한다.
때문에 인접 행렬을 쓰는 것이 유리해보임.
승리하는 관계일 경우 1, 질 경우 -1으로. 설정.
  1  2  3  4  5
1 0  1  0  0  0
2 -1 0 -1  -1 1 
3 0  1  0  -1 0
4 0  1  1  0  0
5 0 -1  0  0  0
가로를 기준으로 이겼을 때 1, 졌을 때 -1
예시에서 2,5번 선수가 순위를 확정할 수 있는 원리
2번 선수는 4명과 붙기 때문에 순위가 확정된다.
5번 선수는 2번 선수와 연결돼 2번 선수가 갖고 있는 -1 * 3과 5번선수 2번 선수와 연결된 -1*1을 하면 -1이 4개가 된다.
  1  2  3  4  5
1 0  1  0  0  0
2 -1 0 -1  1  1 
3 0  1  0  -1 0
4 0 -1  1  0  0
5 0 -1  0  0  0
2번이 4번에게 이기는 것으로 바꾸면
2번은 3위로 확정된다. 5번은 4,5위 중 하나가 될 수 있기 때문에 확정되지 않는다.
# # 2 # #
(1,3) (4,5) => 모순 발생

모순이 없다에는 어떤 조건이 있을까?
1.a가 b를 이기고 b가 c를 이긴다면 a는 반드시 c를 이겨야 한다. c가 a를 이긴다는 결과는 있을 수 없다.
  a  b  c
a 0  1  0
b -1 0  1
c 0 -1  0

2.n개의 참가자가 있을 때 n-1개 이상의 결과를 알고 있어야 한다.
a가 b를 이긴다는 것만 알고 있다면 3개의 순위를 모두 알 수 없다.

3.
  a  b  c  d
a 0  1  0 -1
b -1 0  1  0
c 0 -1  0  0
d 1  0  0  0
d->a a->b b->c
만약 d가 a를 이긴다는 조건이 추가된다면?
d,a,b,c로 순위가 확정되면서 전체 순위를 모두 알 수 있게 된다.
만약 거꾸로 d가 a에게 진다는 조건이 추가된다면 a의 순위는 알 수 있지만 b,c,d의 순위는 알 수 없게 된다.
두가지 케이스의 차이점에 대해 생각해 보자.
  a  b  c  d
a 0  1  0  1
b -1 0  1  0
c 0 -1  0  0
d -1 0  0  0
a->b a->d b->c
위의 인접 리스트를 순서대로 순회하면서 1,-1을 채운다.
a->b인 상황에서 b->c이므로 a->c가 1이 된다.
  a  b  c  d
a 0  1  1  1
b -1 0  1  0
c 0 -1  0  0
d -1 0  0  0
b가 궁금한 것은 d를 이길 수 있나 없나이다. 
b는 a에게 패배하기 때문에 a가 d에게 패배했을 때만 정확하게 그 순위를 알 수 있다.
a->b a->d라면 b,d의 관계를 알 수 없다.
c역시 마찬가지이다. c가 b를 이기지 않는다면 b,d의 관계를 알 수 없다.
즉 b에서 a는 -1, c는 1이다.
a와 d의 관계가 -1, c와 d의 관계가 1이어야 a,c를 통해 b,d의 관계를 알 수 있다.
b<-a, a<-d => b<-d = d->b b에서 d는 -1이므로 b의 순위를 알 수 있게 된다.
하지만 위의 경우에는 1이므로 알 수 없다. c 역시 마찬가지이다.
정리하면 
1.인접행렬에서 해당 노드를 제외한 다른 노드와의 관계를 모두 표시할 수 있어야 순위를 알 수 있다.
2.다른 노드와의 관계를 채울 때 다른 노드를 활용할 수 있는데 
1의 관계일 경우 다른 노드와 알고자하는 노드의 관계역시 1이면 하고 -1일경우 -1이면 알고자하는 노드와 다른 노드의 관계를 알 수 있다.
재귀 사용해서 a->b(1)을 통해 들어가면 b->c(1) c->d(1) 이런식으로 1로 하나하나 들어가면서 숫자를 채우면 된다.
예를 들어 a->b(1)일 경우 b->c(1)이면 a->c(1)를 알 수 있다. 반대의 경우도 마찬가지이다. 
이렇게 했을 경우에 효율성은? 반복문 vs 재귀.
나중에 돌고도 한 번 더 돌면 알 수 있는 경우가 있을까?
재귀와 방향성에 대해 생각해보기.
dfs 접근 방법이기 때문에 재귀를 한번만 해도 모든 관계를 다 살펴볼 수 있다.

3.이 과정을 전 노드에 걸쳐 반복해야 한다. 

인접리스트로 구현하기 위해서는 n^3이다.
모든 노드를 살펴봐야 하기 때문에 비효율이 크다. 이런 비효율을 줄이기 위해서는 인접 행렬보다
인접 리스트를 선택하는 것이 더 좋다.
인접 리스트를 선택할 경우 필요한 노드만 살펴볼 수 있기 때문이다.
다만 승리 관계, 패배 관계 두가지 리스트가 필요하다.
위와 같은 인접리스트 방식과 두가지 관계를 표현한 리스트 두가지 풀이 수도코드 작성.


그래프 순회 알고리즘으로 풀거나 인접 행렬에서 그래도 풀거나
그래프 순회 알고리즘으로 푼다면 weighted, directed 그래프 순회 알고리즘을 사용해야 한다. 



-analysis : 

-find better strategy :

