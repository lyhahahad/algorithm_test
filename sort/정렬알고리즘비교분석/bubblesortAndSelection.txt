*bubble sort
인접한 요소가 잘못된 순서로 돼있을 때 반복적으로 swapping을 진행한다.
0부터 n-1번째 인덱스까지 순서대로 잘못된 순서인 인접 요소들을 swapping한다.
n개의 요소가 있다고 했을 때 n-1번 시행한다.
순회할 때마다 비교는 every case n-1번, swapping은 worst case n-1번, 순회는 every case n-1번 실행된다.
O((n-1)*(n-1+n-1)) => O(n^2)
space는 배열 하나면 되기 때문에 

*insertion sort
정렬되지 않은 부분의 값을 선택해 정렬된 부분의 올바른 위치에 배치한다.
정렬을 n번 실행하면 n번째까지 정렬이 완료된다.
n+1번째 요소를 0부터 n번까지 순서대로 비교해서 큰 요소가 나올때까지 진행하고 큰요소가 나오면 이전 인덱스에 넣는다.
순회는 every case n-1번, 비교, swapping은 worst case (정렬된 배열 개수-1) 
O((n-1)*2*(정렬된 배열 개수-1)) => O(n^2)

*selection sort
반복적으로 가장 작은 값 혹은 큰 값을 찾는 알고리즘
insertion sort와 마찬가지로 sorted part와 unsorted part로 나누어 진행한다.
오름차순으로 정렬한다고 했을 때 1번 인덱스부터 n번 인덱스 중 가장 작은 숫자를 뽑아 0번 인덱스와 swapping한다.
다음은 2번부터 n번까지 이런 시행을 n-1번 시행한다.
처음에 시행할 때는 n-1번의 비교, 순회가 지속될 때마다 비교횟수가 1씩 줄어든다.
n-1 + n-2 + n-3 +.....+1
(n-1)*(n-1 + 1)/2
비교 횟수는 every case에 해당한다.
swapping은 매 순회마다 최대 1번 진행된다.
O((n-1)*(n-1 + 1)/2 * 1) =>O(n^2)

*heap sort
완전 이진 트리를 사용하는 방법으로
root값이 가장 크거나 작도록 유지한다.
오름 차순으로 정렬한다고 했을 때 자식노드는 부모노드보다 크거나 같다.
heap이 주어진다는 가정하에 빅오 분석을 해보면
root노드를 배열에 append하는 식으로 진행하면된다.
root노드를 배열에 추가하고 heap에서 제거하고 heap의 마지막에 있는 노드를 root에 두고 heapify를 진행한다.
이때 비교횟수는 swapping 횟수는 최대 log2(n)이고 비교 횟수는 최대 2*log2(n)이다.
O(log2(n)+2*log2(n))=>o(log2(n))
이런 시행을 배열의 개수만큼 반복한다.
O(n*log2(n))
여기에 input배열을 heap으로 바꿔주는 연산만 더해주면 된다.
heap을 만들기 위해서는 
*linked list vs arraylist 